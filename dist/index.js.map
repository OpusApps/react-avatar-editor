{"version":3,"file":"index.js","sources":["../src/utils/parse-dom.js","../src/utils/retrieve-image-url.js","../src/index.js"],"sourcesContent":["/* global DOMParser:false */\n\n/*\n * This method uses DOMParser to parse an HTML string into\n * a document.  By using this approach we avoid the potential\n * for XSS attacks on consumers of this component, which would\n * be created by parsing the string via a detached DOM fragment,\n * as in this latter case script in onload attributes will be\n * run in the context of the host page.\n *\n * The drawback to this approach is that browser support is not\n * as wide - IE10 and up along with evergreen browsers.\n */\nconst parseDOM = (str) => {\n  const parser = typeof DOMParser === 'undefined' ? null : new DOMParser()\n\n  if (!parser) {\n    return null\n  }\n\n  return parser.parseFromString(str, 'text/html')\n}\n\nexport default parseDOM\n","import parseDOM from './parse-dom'\n\n/*\n * Retrieves image URL from collection of data transfer\n * items, if one is present.  As the item will contain\n * an HTML string containing an img element, it's\n * necessary to parse the HTML and then pull the src\n * attribute off the image.\n */\nconst retrieveImageURL = (dataTransferItems, callback) => {\n  for (let i = 0; i < dataTransferItems.length; i++) {\n    let item = dataTransferItems[i]\n\n    if (item.type === 'text/html') {\n      item.getAsString(value => {\n        const doc = parseDOM(value)\n        const img = doc.querySelector('img')\n        if (img && img.src) {\n          callback(img.src)\n        }\n      })\n      break\n    }\n  }\n}\n\nexport default retrieveImageURL\n","import PropTypes from 'prop-types'\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport retrieveImageUrl from './utils/retrieve-image-url'\n\nconst isTouchDevice = !!(\n  typeof window !== 'undefined' &&\n  typeof navigator !== 'undefined' &&\n  ('ontouchstart' in window || navigator.msMaxTouchPoints > 0)\n)\n\nconst isFileAPISupported = typeof File !== 'undefined'\n\nconst draggableEvents = {\n  touch: {\n    react: {\n      down: 'onTouchStart',\n      mouseDown: 'onMouseDown',\n      drag: 'onTouchMove',\n      drop: 'onTouchEnd',\n      move: 'onTouchMove',\n      mouseMove: 'onMouseMove',\n      up: 'onTouchEnd',\n      mouseUp: 'onMouseUp'\n    },\n    native: {\n      down: 'touchstart',\n      mouseDown: 'mousedown',\n      drag: 'touchmove',\n      drop: 'touchend',\n      move: 'touchmove',\n      mouseMove: 'mousemove',\n      up: 'touchend',\n      mouseUp: 'mouseup'\n    }\n  },\n  desktop: {\n    react: {\n      down: 'onMouseDown',\n      drag: 'onDragOver',\n      drop: 'onDrop',\n      move: 'onMouseMove',\n      up: 'onMouseUp'\n    },\n    native: {\n      down: 'mousedown',\n      drag: 'dragStart',\n      drop: 'drop',\n      move: 'mousemove',\n      up: 'mouseup'\n    }\n  }\n}\nconst deviceEvents = isTouchDevice\n  ? draggableEvents.touch\n  : draggableEvents.desktop\n\nconst pixelRatio =\n  typeof window !== 'undefined' && window.devicePixelRatio\n    ? window.devicePixelRatio\n    : 1\n\nconst drawOpusBorder = (context, x, y, width, height, angleLeftRight = true) => {\n    /**\n     * Creates the non opcity space between boarders.\n     * Replacing the rect that belongs here in order to make\n     * space background image border for opus.\n     */\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x + width, y);\n    if (angleLeftRight) {\n       context.lineTo(x + width, y + (height * 0.75));\n       context.lineTo(x, y + height);\n    } else {\n       context.lineTo(x + width, y + height);\n       context.lineTo(x, y + (height * 0.75));\n    }\n    context.lineTo(x, y);\n}\n\nconst drawGuidLines = (context, x, y, width, height) => {\n     /**\n     * Guide lines for profile picture\n     *        |     |\n     *        |     |\n     *  -------------------\n     *        |     |\n     *        |     |\n     *  -------------------\n     *        |     |\n     *        |     |\n     */\n    var lineColor = \"rgba(151, 151, 151, 0.3)\";\n    var lineWidth = 1;\n\n    // vertical guide left\n    context.beginPath();\n    context.moveTo(x + (width / 3), y);\n    context.lineTo(x + (width / 3), y + height);\n    context.strokeStyle = lineColor;\n    context.lineWidth = lineWidth;\n    context.stroke();\n\n    // vertical guide right\n    context.beginPath();\n    context.moveTo(x + (width / 3 * 2), y);\n    context.lineTo(x + (width / 3 * 2), y + height);\n    context.strokeStyle = lineColor;\n    context.lineWidth = lineWidth;\n    context.stroke();\n\n    // horizontal guide top \n    context.beginPath();\n    context.moveTo(x, y + (height / 3));\n    context.lineTo(x + width, y + (height / 3));\n    context.strokeStyle = lineColor;\n    context.lineWidth = lineWidth;\n    context.stroke();\n   \n   // horizontal guide bottom\n    context.beginPath();\n    context.moveTo(x, y + (height / 3 * 2));\n    context.lineTo(x + width, y + (height / 3 * 2));\n    context.strokeStyle = lineColor;\n    context.lineWidth = lineWidth;\n    context.stroke();\n\n    context.moveTo(x, y);\n}\n\n// Draws a rounded rectangle on a 2D context.\nconst drawRoundedRect = (context, x, y, width, height, borderRadius, showOpusBorder, changeOpusBorderAngel) => {\n  const isNoBoarder = borderRadius === 0;\n\n  if (isNoBoarder && !showOpusBorder) {\n    context.rect(x, y, width, height)\n  } else if (isNoBoarder && showOpusBorder) {\n      drawOpusBorder(\n        context,\n        x,\n        y,\n        width,\n        height,\n        !changeOpusBorderAngel\n      )\n  } else {\n    const widthMinusRad = width - borderRadius\n    const heightMinusRad = height - borderRadius\n    context.translate(x, y)\n    context.arc(\n      borderRadius,\n      borderRadius,\n      borderRadius,\n      Math.PI,\n      Math.PI * 1.5\n    )\n    context.lineTo(widthMinusRad, 0)\n    context.arc(\n      widthMinusRad,\n      borderRadius,\n      borderRadius,\n      Math.PI * 1.5,\n      Math.PI * 2\n    )\n    context.lineTo(width, heightMinusRad)\n    context.arc(\n      widthMinusRad,\n      heightMinusRad,\n      borderRadius,\n      Math.PI * 2,\n      Math.PI * 0.5\n    )\n    context.lineTo(borderRadius, height)\n    context.arc(\n      borderRadius,\n      heightMinusRad,\n      borderRadius,\n      Math.PI * 0.5,\n      Math.PI\n    )\n    context.translate(-x, -y);\n  }\n}\n\nclass AvatarEditor extends React.Component {\n  static propTypes = {\n    scale: PropTypes.number,\n    rotate: PropTypes.number,\n    image: PropTypes.oneOfType([\n      PropTypes.string,\n      ...(isFileAPISupported ? [PropTypes.instanceOf(File)] : [])\n    ]),\n    border: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.arrayOf(PropTypes.number)\n    ]),\n    borderRadius: PropTypes.number,\n    width: PropTypes.number,\n    height: PropTypes.number,\n    position: PropTypes.shape({\n      x: PropTypes.number,\n      y: PropTypes.number\n    }),\n    color: PropTypes.arrayOf(PropTypes.number),\n    style: PropTypes.object,\n    crossOrigin: PropTypes.oneOf(['', 'anonymous', 'use-credentials']),\n\n    onDropFile: PropTypes.func,\n    onLoadFailure: PropTypes.func,\n    onLoadSuccess: PropTypes.func,\n    onImageReady: PropTypes.func,\n    onImageChange: PropTypes.func,\n    onMouseUp: PropTypes.func,\n    onMouseMove: PropTypes.func,\n    onPositionChange: PropTypes.func,\n\n    disableDrop: PropTypes.bool,\n    showGridGuides: PropTypes.bool,\n    showOpusBorder: PropTypes.bool,\n    changeOpusBorderAngel: PropTypes.bool,\n  }\n\n  static defaultProps = {\n    disableDrop: false,\n    scale: 1,\n    rotate: 0,\n    border: 25,\n    borderRadius: 0,\n    width: 200,\n    height: 200,\n    color: [0, 0, 0, 0.5],\n    style: {},\n    onDropFile () {},\n    onLoadFailure () {},\n    onLoadSuccess () {},\n    onImageReady () {},\n    onImageChange () {},\n    onMouseUp () {},\n    onMouseMove () {},\n    onPositionChange () {}\n  }\n\n  state = {\n    drag: false,\n    my: null,\n    mx: null,\n    image: {\n      x: 0.5,\n      y: 0.5\n    }\n  }\n\n  isVertical () {\n    return this.props.rotate % 180 !== 0\n  }\n\n  getBorders (border = this.props.border) {\n    return Array.isArray(border) ? border : [border, border]\n  }\n\n  getDimensions () {\n    const { width, height, rotate, border } = this.props\n\n    const canvas = {}\n\n    const [borderX, borderY] = this.getBorders(border)\n\n    const canvasWidth = width\n    const canvasHeight = height\n\n    if (this.isVertical()) {\n      canvas.width = canvasHeight\n      canvas.height = canvasWidth\n    } else {\n      canvas.width = canvasWidth\n      canvas.height = canvasHeight\n    }\n\n    canvas.width += borderX * 2\n    canvas.height += borderY * 2\n\n    return {\n      canvas,\n      rotate,\n      width,\n      height,\n      border\n    }\n  }\n\n  getImage () {\n    // get relative coordinates (0 to 1)\n    const cropRect = this.getCroppingRect()\n    const image = this.state.image\n\n    // get actual pixel coordinates\n    cropRect.x *= image.resource.width\n    cropRect.y *= image.resource.height\n    cropRect.width *= image.resource.width\n    cropRect.height *= image.resource.height\n\n    // create a canvas with the correct dimensions\n    const canvas = document.createElement('canvas')\n\n    if (this.isVertical()) {\n      canvas.width = cropRect.height\n      canvas.height = cropRect.width\n    } else {\n      canvas.width = cropRect.width\n      canvas.height = cropRect.height\n    }\n\n    // draw the full-size image at the correct position,\n    // the image gets truncated to the size of the canvas.\n    const context = canvas.getContext('2d')\n\n    context.translate(canvas.width / 2, canvas.height / 2)\n    context.rotate(this.props.rotate * Math.PI / 180)\n    context.translate(-(canvas.width / 2), -(canvas.height / 2))\n\n    if (this.isVertical()) {\n      context.translate(\n        (canvas.width - canvas.height) / 2,\n        (canvas.height - canvas.width) / 2\n      )\n    }\n\n    context.drawImage(image.resource, -cropRect.x, -cropRect.y)\n\n    return canvas\n  }\n\n  /**\n   * Get the image scaled to original canvas size.\n   * This was default in 4.x and is now kept as a legacy method.\n   */\n  getImageScaledToCanvas () {\n    const { width, height } = this.getDimensions()\n\n    const canvas = document.createElement('canvas')\n\n    if (this.isVertical()) {\n      canvas.width = height\n      canvas.height = width\n    } else {\n      canvas.width = width\n      canvas.height = height\n    }\n\n    // don't paint a border here, as it is the resulting image\n    this.paintImage(canvas.getContext('2d'), this.state.image, 0, 1)\n\n    return canvas\n  }\n\n  getXScale () {\n    const canvasAspect = this.props.width / this.props.height\n    const imageAspect = this.state.image.width / this.state.image.height\n\n    return Math.min(1, canvasAspect / imageAspect)\n  }\n\n  getYScale () {\n    const canvasAspect = this.props.height / this.props.width\n    const imageAspect = this.state.image.height / this.state.image.width\n\n    return Math.min(1, canvasAspect / imageAspect)\n  }\n\n  getCroppingRect () {\n    const position = this.props.position || {\n      x: this.state.image.x,\n      y: this.state.image.y\n    }\n    const width = 1 / this.props.scale * this.getXScale()\n    const height = 1 / this.props.scale * this.getYScale()\n\n    const croppingRect = {\n      x: position.x - width / 2,\n      y: position.y - height / 2,\n      width,\n      height\n    }\n\n    let xMin = 0\n    let xMax = 1 - croppingRect.width\n    let yMin = 0\n    let yMax = 1 - croppingRect.height\n\n    // If the cropping rect is larger than the image, then we need to change\n    // our maxima & minima for x & y to allow the image to appear anywhere up\n    // to the very edge of the cropping rect.\n    const isLargerThanImage = width > 1 || height > 1\n\n    if (isLargerThanImage) {\n      xMin = -croppingRect.width\n      xMax = 1\n      yMin = -croppingRect.height\n      yMax = 1\n    }\n\n    return {\n      ...croppingRect,\n      x: Math.max(xMin, Math.min(croppingRect.x, xMax)),\n      y: Math.max(yMin, Math.min(croppingRect.y, yMax))\n    }\n  }\n\n  isDataURL (str) {\n    if (str === null) {\n      return false\n    }\n    const regex = /^\\s*data:([a-z]+\\/[a-z]+(;[a-z-]+=[a-z-]+)?)?(;base64)?,[a-z0-9!$&',()*+;=\\-._~:@/?%\\s]*\\s*$/i\n    return !!str.match(regex)\n  }\n\n  loadImage (image) {\n    if (isFileAPISupported && image instanceof File) {\n      this.loadImageFile(image)\n    } else if (typeof image === 'string') {\n      this.loadImageURL(image)\n    }\n  }\n\n  loadImageURL (imageURL) {\n    const imageObj = new Image()\n    imageObj.onload = this.handleImageReady.bind(this, imageObj)\n    imageObj.onerror = this.props.onLoadFailure\n    if (!this.isDataURL(imageURL) && this.props.crossOrigin) { imageObj.crossOrigin = this.props.crossOrigin }\n    imageObj.src = imageURL\n  }\n\n  loadImageFile (imageFile) {\n    const reader = new FileReader()\n    reader.onload = e => this.loadImageURL(e.target.result)\n    reader.readAsDataURL(imageFile)\n  }\n\n  componentDidMount () {\n    const context = ReactDOM.findDOMNode(this.canvas).getContext('2d')\n    if (this.props.image) {\n      this.loadImage(this.props.image)\n    }\n    this.paint(context)\n    if (document) {\n      const nativeEvents = deviceEvents.native\n      document.addEventListener(nativeEvents.move, this.handleMouseMove, false)\n      document.addEventListener(nativeEvents.up, this.handleMouseUp, false)\n      if (isTouchDevice) {\n        document.addEventListener(\n          nativeEvents.mouseMove,\n          this.handleMouseMove,\n          false\n        )\n        document.addEventListener(\n          nativeEvents.mouseUp,\n          this.handleMouseUp,\n          false\n        )\n      }\n    }\n  }\n\n  componentWillUnmount () {\n    if (document) {\n      const nativeEvents = deviceEvents.native\n      document.removeEventListener(\n        nativeEvents.move,\n        this.handleMouseMove,\n        false\n      )\n      document.removeEventListener(nativeEvents.up, this.handleMouseUp, false)\n      if (isTouchDevice) {\n        document.removeEventListener(\n          nativeEvents.mouseMove,\n          this.handleMouseMove,\n          false\n        )\n        document.removeEventListener(\n          nativeEvents.mouseUp,\n          this.handleMouseUp,\n          false\n        )\n      }\n    }\n  }\n\n  componentDidUpdate (prevProps, prevState) {\n    const canvas = ReactDOM.findDOMNode(this.canvas)\n    const context = canvas.getContext('2d')\n    context.clearRect(0, 0, canvas.width, canvas.height)\n    this.paint(context)\n    this.paintImage(context, this.state.image, this.props.border)\n\n    if (\n      prevProps.image !== this.props.image ||\n      prevProps.width !== this.props.width ||\n      prevProps.height !== this.props.height ||\n      prevProps.position !== this.props.position ||\n      prevProps.scale !== this.props.scale ||\n      prevProps.rotate !== this.props.rotate ||\n      prevState.my !== this.state.my ||\n      prevState.mx !== this.state.mx ||\n      prevState.image.x !== this.state.image.x ||\n      prevState.image.y !== this.state.image.y\n    ) {\n      this.props.onImageChange()\n    }\n  }\n\n  handleImageReady (image) {\n    const imageState = this.getInitialSize(image.width, image.height)\n    imageState.resource = image\n    imageState.x = 0.5\n    imageState.y = 0.5\n    this.setState({ drag: false, image: imageState }, this.props.onImageReady)\n    this.props.onLoadSuccess(imageState)\n  }\n\n  getInitialSize (width, height) {\n    let newHeight\n    let newWidth\n\n    const dimensions = this.getDimensions()\n    const canvasRatio = dimensions.height / dimensions.width\n    const imageRatio = height / width\n\n    if (canvasRatio > imageRatio) {\n      newHeight = this.getDimensions().height\n      newWidth = width * (newHeight / height)\n    } else {\n      newWidth = this.getDimensions().width\n      newHeight = height * (newWidth / width)\n    }\n\n    return {\n      height: newHeight,\n      width: newWidth\n    }\n  }\n\n  componentWillReceiveProps (newProps) {\n    if (\n      (newProps.image && this.props.image !== newProps.image) ||\n      this.props.width !== newProps.width ||\n      this.props.height !== newProps.height\n    ) {\n      this.loadImage(newProps.image)\n    }\n  }\n\n  paintImage (context, image, border, scaleFactor = pixelRatio) {\n    if (image.resource) {\n      const position = this.calculatePosition(image, border)\n\n      context.save()\n\n      context.translate(context.canvas.width / 2, context.canvas.height / 2)\n      context.rotate(this.props.rotate * Math.PI / 180)\n      context.translate(\n        -(context.canvas.width / 2),\n        -(context.canvas.height / 2)\n      )\n\n      if (this.isVertical()) {\n        context.translate(\n          (context.canvas.width - context.canvas.height) / 2,\n          (context.canvas.height - context.canvas.width) / 2\n        )\n      }\n\n      context.scale(scaleFactor, scaleFactor)\n\n      context.globalCompositeOperation = 'destination-over'\n      context.drawImage(\n        image.resource,\n        position.x,\n        position.y,\n        position.width,\n        position.height\n      )\n\n      context.restore()\n    }\n  }\n\n  calculatePosition (image, border) {\n    image = image || this.state.image\n\n    const [borderX, borderY] = this.getBorders(border)\n\n    const croppingRect = this.getCroppingRect()\n\n    const width = image.width * this.props.scale\n    const height = image.height * this.props.scale\n\n    let x = -croppingRect.x * width\n    let y = -croppingRect.y * height\n\n    if (this.isVertical()) {\n      x += borderY\n      y += borderX\n    } else {\n      x += borderX\n      y += borderY\n    }\n\n    return {\n      x,\n      y,\n      height,\n      width\n    }\n  }\n\n  paint (context) {\n    context.save()\n    context.scale(pixelRatio, pixelRatio)\n    context.translate(0, 0)\n    context.fillStyle = 'rgba(' + this.props.color.slice(0, 4).join(',') + ')'\n\n    let borderRadius = this.props.borderRadius\n    const changeOpusBorderAngel = this.props.changeOpusBorderAngel\n    const showGridGuides = this.props.showGridGuides\n    const showOpusBorder = this.props.showOpusBorder\n\n    const dimensions = this.getDimensions()\n    const [borderSizeX, borderSizeY] = this.getBorders(dimensions.border)\n    const height = dimensions.canvas.height\n    const width = dimensions.canvas.width\n\n    // clamp border radius between zero (perfect rectangle) and half the size without borders (perfect circle or \"pill\")\n    borderRadius = Math.max(borderRadius, 0)\n    borderRadius = Math.min(\n      borderRadius,\n      width / 2 - borderSizeX,\n      height / 2 - borderSizeY\n    )\n\n    console.log(\"props in r a e\", this.props)\n    console.log(\"changeOpusBorderAngel in r a e\", changeOpusBorderAngel)\n    console.log(\"showOpusBorder in r a e\", showOpusBorder)\n\n    context.beginPath()\n\n    if (showGridGuides) {\n      drawGuidLines(\n          context,\n          borderSizeX,\n          borderSizeY,\n          width - borderSizeX * 2,\n          height - borderSizeY * 2,\n      )\n    }\n\n    // inner rect, possibly rounded\n    drawRoundedRect(\n      context,\n      borderSizeX,\n      borderSizeY,\n      width - borderSizeX * 2,\n      height - borderSizeY * 2,\n      borderRadius,\n      showOpusBorder,\n      changeOpusBorderAngel\n    )\n    context.rect(width, 0, -width, height) // outer rect, drawn \"counterclockwise\"\n    context.fill('evenodd')\n\n    context.restore()\n  }\n\n  handleMouseDown = (e) => {\n    e = e || window.event\n    // if e is a touch event, preventDefault keeps\n    // corresponding mouse events from also being fired\n    // later.\n    e.preventDefault()\n    this.setState({\n      drag: true,\n      mx: null,\n      my: null\n    })\n  }\n  handleMouseUp = () => {\n    if (this.state.drag) {\n      this.setState({ drag: false })\n      this.props.onMouseUp()\n    }\n  }\n\n  handleMouseMove = (e) => {\n    e = e || window.event\n    if (this.state.drag === false) {\n      return\n    }\n\n    const mousePositionX = e.targetTouches\n      ? e.targetTouches[0].pageX\n      : e.clientX\n    const mousePositionY = e.targetTouches\n      ? e.targetTouches[0].pageY\n      : e.clientY\n\n    const newState = {\n      mx: mousePositionX,\n      my: mousePositionY\n    }\n\n    let rotate = this.props.rotate\n\n    rotate %= 360\n    rotate = rotate < 0 ? rotate + 360 : rotate\n\n    if (this.state.mx && this.state.my) {\n      const mx = this.state.mx - mousePositionX\n      const my = this.state.my - mousePositionY\n\n      const width = this.state.image.width * this.props.scale\n      const height = this.state.image.height * this.props.scale\n\n      let { x: lastX, y: lastY } = this.getCroppingRect()\n\n      lastX *= width\n      lastY *= height\n\n      // helpers to calculate vectors\n      const toRadians = degree => degree * (Math.PI / 180)\n      const cos = Math.cos(toRadians(rotate))\n      const sin = Math.sin(toRadians(rotate))\n\n      const x = lastX + mx * cos + my * sin\n      const y = lastY + -mx * sin + my * cos\n\n      const relativeWidth = 1 / this.props.scale * this.getXScale()\n      const relativeHeight = 1 / this.props.scale * this.getYScale()\n\n      const position = {\n        x: x / width + relativeWidth / 2,\n        y: y / height + relativeHeight / 2\n      }\n\n      this.props.onPositionChange(position)\n\n      newState.image = {\n        ...this.state.image,\n        ...position\n      }\n    }\n\n    this.setState(newState)\n\n    this.props.onMouseMove(e)\n  }\n\n  handleDragOver = (e) => {\n    e = e || window.event\n    e.preventDefault()\n  }\n\n  handleDrop = (e = window.event) => {\n    e.stopPropagation()\n    e.preventDefault()\n\n    if (e.dataTransfer) {\n      const { files, items } = e.dataTransfer\n\n      if (files && files.length) {\n        this.props.onDropFile(e)\n        this.loadImageFile(files[0])\n      } else if (items && items.length) {\n        retrieveImageUrl(items, src => this.loadImage(src))\n      }\n    }\n  }\n\n  setCanvas = (canvas) => {\n    this.canvas = canvas\n  }\n\n  render () {\n    const dimensions = this.getDimensions()\n    const defaultStyle = {\n      width: dimensions.canvas.width,\n      height: dimensions.canvas.height,\n      cursor: this.state.drag ? 'grabbing' : 'grab'\n    }\n\n    const attributes = {\n      width: dimensions.canvas.width * pixelRatio,\n      height: dimensions.canvas.height * pixelRatio,\n      style: {\n        ...defaultStyle,\n        ...this.props.style\n      }\n    }\n\n    attributes[deviceEvents.react.down] = this.handleMouseDown\n    attributes[deviceEvents.react.drag] = this.handleDragOver\n    if (!this.props.disableDrop) { attributes[deviceEvents.react.drop] = this.handleDrop }\n    if (isTouchDevice) { attributes[deviceEvents.react.mouseDown] = this.handleMouseDown }\n\n    return <canvas ref={this.setCanvas} {...attributes} />\n  }\n}\n\nexport default AvatarEditor\n"],"names":["parseDOM","str","parser","DOMParser","parseFromString","retrieveImageURL","dataTransferItems","callback","i","length","item","type","getAsString","img","value","querySelector","src","isTouchDevice","window","navigator","msMaxTouchPoints","isFileAPISupported","File","draggableEvents","deviceEvents","touch","desktop","pixelRatio","devicePixelRatio","drawOpusBorder","context","x","y","width","height","angleLeftRight","beginPath","moveTo","lineTo","drawGuidLines","lineColor","strokeStyle","lineWidth","stroke","drawRoundedRect","borderRadius","showOpusBorder","changeOpusBorderAngel","isNoBoarder","rect","widthMinusRad","heightMinusRad","translate","arc","Math","PI","AvatarEditor","state","handleMouseDown","e","event","preventDefault","setState","handleMouseUp","_this","drag","props","onMouseUp","handleMouseMove","mousePositionX","targetTouches","pageX","clientX","mousePositionY","pageY","clientY","newState","rotate","mx","my","image","scale","getCroppingRect","lastX","lastY","toRadians","degree","cos","sin","position","getXScale","getYScale","onPositionChange","onMouseMove","handleDragOver","handleDrop","stopPropagation","dataTransfer","files","items","onDropFile","loadImageFile","loadImage","setCanvas","canvas","React","Component","this","border","Array","isArray","getBorders","borderX","borderY","canvasWidth","canvasHeight","isVertical","cropRect","resource","document","createElement","getContext","drawImage","getDimensions","paintImage","canvasAspect","imageAspect","min","croppingRect","xMin","xMax","yMin","yMax","max","regex","match","loadImageURL","imageURL","imageObj","Image","onload","handleImageReady","bind","onerror","onLoadFailure","isDataURL","crossOrigin","imageFile","reader","FileReader","_this2","target","result","readAsDataURL","ReactDOM","findDOMNode","paint","nativeEvents","native","addEventListener","move","up","mouseMove","mouseUp","removeEventListener","prevProps","prevState","clearRect","onImageChange","imageState","getInitialSize","onImageReady","onLoadSuccess","newHeight","newWidth","dimensions","newProps","scaleFactor","calculatePosition","save","globalCompositeOperation","restore","fillStyle","color","slice","join","showGridGuides","borderSizeX","borderSizeY","log","fill","defaultStyle","attributes","style","react","down","disableDrop","drop","mouseDown","ref","propTypes","PropTypes","number","oneOfType","string","instanceOf","arrayOf","shape","object","oneOf","func","bool","defaultProps"],"mappings":"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"}